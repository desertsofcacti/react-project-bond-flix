// HACK depending on these constants is not ideal
import { SRC_ENTRIES } from '../plugins/vite-plugin-rsc-managed.js';
const messageCallbacks = new Map();
let workerPromise;
export function initializeWorker(config) {
    if (workerPromise) {
        throw new Error('Worker already initialized');
    }
    workerPromise = new Promise((resolve, reject)=>{
        Promise.all([
            import('node:worker_threads').catch((e)=>{
                throw e;
            }),
            import('node:module').catch((e)=>{
                throw e;
            })
        ]).then(([{ Worker, setEnvironmentData }, { default: module }])=>{
            const HAS_MODULE_REGISTER = typeof module.register === 'function';
            setEnvironmentData('__WAKU_PRIVATE_ENV__', globalThis.__WAKU_PRIVATE_ENV__);
            setEnvironmentData('CONFIG_BASE_PATH', config.basePath);
            setEnvironmentData('CONFIG_SRC_DIR', config.srcDir);
            setEnvironmentData('CONFIG_ENTRIES', SRC_ENTRIES);
            setEnvironmentData('CONFIG_PRIVATE_DIR', config.privateDir);
            const worker = new Worker(new URL('dev-worker-impl.js', import.meta.url), {
                execArgv: [
                    ...HAS_MODULE_REGISTER ? [] : [
                        '--experimental-loader',
                        'waku/node-loader'
                    ],
                    '--conditions',
                    'react-server',
                    'workerd'
                ]
            });
            worker.on('message', (mesg)=>{
                if ('id' in mesg) {
                    messageCallbacks.get(mesg.id)?.(mesg);
                }
            });
            resolve(worker);
        }).catch(reject);
    });
}
const getWorker = ()=>{
    if (!workerPromise) {
        throw new Error('Worker not initialized');
    }
    return workerPromise;
};
export function registerHotUpdateCallback(fn) {
    getWorker().then((worker)=>{
        const listener = (mesg)=>{
            if (mesg.type === 'hot-update') {
                fn(mesg.payload);
            }
        };
        worker.on('message', listener);
    }).catch((e)=>{
        console.error('Failed to register hot update callback', e);
    });
}
let nextId = 1;
export async function renderRscWithWorker(args, opts) {
    const worker = await getWorker();
    const id = nextId++;
    let started = false;
    return new Promise((resolve, reject)=>{
        messageCallbacks.set(id, (mesg)=>{
            if (mesg.type === 'start') {
                if (!started) {
                    started = true;
                    const bridge = new TransformStream({
                        flush () {
                            messageCallbacks.delete(id);
                        }
                    });
                    Object.entries(mesg.context || {}).forEach(([key, value])=>{
                        if (args.context) {
                            args.context[key] = value;
                        }
                    });
                    resolve(mesg.stream.pipeThrough(bridge));
                } else {
                    throw new Error('already started');
                }
            } else if (mesg.type === 'moduleId') {
                args.moduleIdCallback?.(mesg.moduleId);
            } else if (mesg.type === 'err') {
                const err = typeof mesg.err === 'string' ? new Error(mesg.err) : mesg.err;
                if (mesg.statusCode) {
                    err.statusCode = mesg.statusCode;
                }
                if (!started) {
                    reject(err);
                }
                messageCallbacks.delete(id);
            }
        });
        const mesg = {
            id,
            type: 'render',
            config: args.config,
            input: args.input,
            searchParamsString: args.searchParams.toString(),
            initialModules: opts.initialModules,
            method: args.method,
            context: args.context,
            body: args.body,
            contentType: args.contentType,
            hasModuleIdCallback: !!args.moduleIdCallback
        };
        worker.postMessage(mesg, args.body ? [
            args.body
        ] : undefined);
    });
}
export async function getSsrConfigWithWorker(args, opts) {
    const worker = await getWorker();
    const id = nextId++;
    return new Promise((resolve, reject)=>{
        messageCallbacks.set(id, (mesg)=>{
            if (mesg.type === 'ssrConfig') {
                resolve({
                    input: mesg.input,
                    ...mesg.searchParamsString ? {
                        searchParams: new URLSearchParams(mesg.searchParamsString)
                    } : {},
                    body: mesg.body
                });
                messageCallbacks.delete(id);
            } else if (mesg.type === 'noSsrConfig') {
                resolve(null);
                messageCallbacks.delete(id);
            } else if (mesg.type === 'err') {
                const err = typeof mesg.err === 'string' ? new Error(mesg.err) : mesg.err;
                if (mesg.statusCode) {
                    err.statusCode = mesg.statusCode;
                }
                reject(err);
                messageCallbacks.delete(id);
            }
        });
        const mesg = {
            id,
            type: 'getSsrConfig',
            config: args.config,
            pathname: args.pathname,
            initialModules: opts.initialModules,
            searchParamsString: args.searchParams.toString()
        };
        worker.postMessage(mesg);
    });
}
