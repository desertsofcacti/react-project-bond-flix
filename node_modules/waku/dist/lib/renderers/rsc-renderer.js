import { filePathToFileURL } from '../utils/path.js';
import { parseFormData } from '../utils/form.js';
import { streamToString } from '../utils/stream.js';
import { decodeActionId } from '../renderers/utils.js';
export const SERVER_MODULE_MAP = {
    'rsdw-server': 'react-server-dom-webpack/server.edge',
    'waku-server': 'waku/server'
};
const resolveClientEntryForPrd = (id, config)=>{
    if (!id.startsWith('@id/')) {
        throw new Error('Unexpected client entry in PRD');
    }
    return config.basePath + id.slice('@id/'.length);
};
export async function renderRsc(args, opts) {
    const { config, input, searchParams, method, contentType, context, body, moduleIdCallback } = args;
    const { isDev, entries } = opts;
    const resolveClientEntry = isDev ? opts.resolveClientEntry : resolveClientEntryForPrd;
    const { default: { renderEntries }, loadModule, buildConfig } = entries;
    const loadServerModule = (key)=>isDev ? import(/* @vite-ignore */ SERVER_MODULE_MAP[key]) : loadModule(key);
    const [{ default: { renderToReadableStream, decodeReply } }, { runWithRenderStore }] = await Promise.all([
        loadServerModule('rsdw-server'),
        loadServerModule('waku-server')
    ]);
    const bundlerConfig = new Proxy({}, {
        get (_target, encodedId) {
            const [file, name] = encodedId.split('#');
            const id = resolveClientEntry(file, config);
            moduleIdCallback?.(id);
            return {
                id,
                chunks: [
                    id
                ],
                name,
                async: true
            };
        }
    });
    const renderWithContext = async (context, input, searchParams)=>{
        const renderStore = {
            context: context || {},
            rerender: ()=>{
                throw new Error('Cannot rerender');
            }
        };
        return runWithRenderStore(renderStore, async ()=>{
            const elements = await renderEntries(input, {
                searchParams,
                buildConfig
            });
            if (elements === null) {
                const err = new Error('No function component found');
                err.statusCode = 404; // HACK our convention for NotFound
                throw err;
            }
            if (Object.keys(elements).some((key)=>key.startsWith('_'))) {
                throw new Error('"_" prefix is reserved');
            }
            return renderToReadableStream(elements, bundlerConfig);
        });
    };
    const renderWithContextWithAction = async (context, actionFn, actionArgs)=>{
        let elementsPromise = Promise.resolve({});
        let rendered = false;
        const renderStore = {
            context: context || {},
            rerender: async (input, searchParams = new URLSearchParams())=>{
                if (rendered) {
                    throw new Error('already rendered');
                }
                elementsPromise = Promise.all([
                    elementsPromise,
                    renderEntries(input, {
                        searchParams,
                        buildConfig
                    })
                ]).then(([oldElements, newElements])=>({
                        ...oldElements,
                        // FIXME we should actually check if newElements is null and send an error
                        ...newElements
                    }));
            }
        };
        return runWithRenderStore(renderStore, async ()=>{
            const actionValue = await actionFn(...actionArgs);
            const elements = await elementsPromise;
            rendered = true;
            if (Object.keys(elements).some((key)=>key.startsWith('_'))) {
                throw new Error('"_" prefix is reserved');
            }
            return renderToReadableStream({
                ...elements,
                _value: actionValue
            }, bundlerConfig);
        });
    };
    if (method === 'POST') {
        const rsfId = decodeActionId(input);
        let args = [];
        let bodyStr = '';
        if (body) {
            bodyStr = await streamToString(body);
        }
        if (typeof contentType === 'string' && contentType.startsWith('multipart/form-data')) {
            // XXX This doesn't support streaming unlike busboy
            const formData = parseFormData(bodyStr, contentType);
            args = await decodeReply(formData);
        } else if (bodyStr) {
            args = await decodeReply(bodyStr);
        }
        const [fileId, name] = rsfId.split('#');
        let mod;
        if (isDev) {
            mod = await opts.loadServerFile(filePathToFileURL(fileId));
        } else {
            if (!fileId.startsWith('@id/')) {
                throw new Error('Unexpected server entry in PRD');
            }
            mod = await loadModule(fileId.slice('@id/'.length));
        }
        const fn = mod[name] || mod;
        return renderWithContextWithAction(context, fn, args);
    }
    // method === 'GET'
    return renderWithContext(context, input, searchParams);
}
export async function getBuildConfig(opts) {
    const { config, entries } = opts;
    const { default: { getBuildConfig } } = entries;
    if (!getBuildConfig) {
        console.warn("getBuildConfig is undefined. It's recommended for optimization and sometimes required.");
        return [];
    }
    const unstable_collectClientModules = async (input)=>{
        const idSet = new Set();
        const readable = await renderRsc({
            config,
            input,
            searchParams: new URLSearchParams(),
            method: 'GET',
            context: undefined,
            moduleIdCallback: (id)=>idSet.add(id)
        }, {
            isDev: false,
            entries
        });
        await new Promise((resolve, reject)=>{
            const writable = new WritableStream({
                close () {
                    resolve();
                },
                abort (reason) {
                    reject(reason);
                }
            });
            readable.pipeTo(writable).catch(reject);
        });
        return Array.from(idSet);
    };
    const output = await getBuildConfig(unstable_collectClientModules);
    return output;
}
export async function getSsrConfig(args, opts) {
    const { config, pathname, searchParams } = args;
    const { isDev, entries } = opts;
    const resolveClientEntry = isDev ? opts.resolveClientEntry : resolveClientEntryForPrd;
    const { default: { getSsrConfig }, loadModule, buildConfig } = entries;
    const { renderToReadableStream } = await (isDev ? import(/* @vite-ignore */ SERVER_MODULE_MAP['rsdw-server']) : loadModule('rsdw-server').then((m)=>m.default));
    const ssrConfig = await getSsrConfig?.(pathname, {
        searchParams,
        buildConfig
    });
    if (!ssrConfig) {
        return null;
    }
    const bundlerConfig = new Proxy({}, {
        get (_target, encodedId) {
            const [file, name] = encodedId.split('#');
            const id = resolveClientEntry(file, config);
            return {
                id,
                chunks: [
                    id
                ],
                name,
                async: true
            };
        }
    });
    return {
        ...ssrConfig,
        body: renderToReadableStream(ssrConfig.body, bundlerConfig)
    };
}
