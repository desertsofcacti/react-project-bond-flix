import { injectRSCPayload } from 'rsc-html-stream/server';
import { concatUint8Arrays } from '../utils/stream.js';
import { joinPath, filePathToFileURL, fileURLToFilePath, encodeFilePathToAbsolute } from '../utils/path.js';
import { encodeInput, hasStatusCode } from './utils.js';
// HACK depending on these constants is not ideal
import { SRC_MAIN } from '../plugins/vite-plugin-rsc-managed.js';
import { DIST_SSR } from '../builder/constants.js';
export const CLIENT_MODULE_MAP = {
    react: 'react',
    'rd-server': 'react-dom/server.edge',
    'rsdw-client': 'react-server-dom-webpack/client.edge',
    'waku-client': 'waku/client'
};
export const CLIENT_PREFIX = 'client/';
// HACK for react-server-dom-webpack without webpack
globalThis.__webpack_module_loading__ ||= new Map();
globalThis.__webpack_module_cache__ ||= new Map();
globalThis.__webpack_chunk_load__ ||= async (id)=>globalThis.__webpack_module_loading__.get(id);
globalThis.__webpack_require__ ||= (id)=>globalThis.__webpack_module_cache__.get(id);
const moduleLoading = globalThis.__webpack_module_loading__;
const moduleCache = globalThis.__webpack_module_cache__;
const fakeFetchCode = `
Promise.resolve(new Response(new ReadableStream({
  start(c) {
    const d = (self.__FLIGHT_DATA ||= []);
    const t = new TextEncoder();
    const f = (s) => c.enqueue(typeof s === 'string' ? t.encode(s) : s);
    d.forEach(f);
    d.push = f;
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => c.close());
    } else {
      c.close();
    }
  }
})))
`.split('\n').map((line)=>line.trim()).join('');
const injectScript = (urlForFakeFetch, mainJsPath)=>{
    const modifyHead = (data)=>{
        const matchPrefetched = data.match(// HACK This is very brittle
        /(.*<script[^>]*>\nglobalThis\.__WAKU_PREFETCHED__ = {\n)(.*?)(\n};.*)/s);
        if (matchPrefetched) {
            data = matchPrefetched[1] + `  '${urlForFakeFetch}': ${fakeFetchCode},` + matchPrefetched[3];
        }
        const closingHeadIndex = data.indexOf('</head>');
        if (closingHeadIndex === -1) {
            throw new Error('closing head not found');
        }
        let code = '';
        if (!matchPrefetched) {
            code += `
globalThis.__WAKU_PREFETCHED__ = {
  '${urlForFakeFetch}': ${fakeFetchCode},
};
`;
        }
        if (code) {
            data = data.slice(0, closingHeadIndex) + `<script type="module" async>${code}</script>` + data.slice(closingHeadIndex);
        }
        return data;
    };
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    let headSent = false;
    let data = '';
    return new TransformStream({
        transform (chunk, controller) {
            if (!(chunk instanceof Uint8Array)) {
                throw new Error('Unknown chunk type');
            }
            data += decoder.decode(chunk);
            if (!headSent) {
                if (!/<\/head><body[^>]*>/.test(data)) {
                    return;
                }
                headSent = true;
                data = modifyHead(data);
                if (mainJsPath) {
                    const closingBodyIndex = data.indexOf('</body>');
                    const [firstPart, secondPart] = closingBodyIndex === -1 ? [
                        data,
                        ''
                    ] : [
                        data.slice(0, closingBodyIndex),
                        data.slice(closingBodyIndex)
                    ];
                    data = firstPart + `<script src="${mainJsPath}" async type="module"></script>` + secondPart;
                }
            }
            controller.enqueue(encoder.encode(data));
            data = '';
        }
    });
};
// HACK for now, do we want to use HTML parser?
const rectifyHtml = ()=>{
    const pending = [];
    const decoder = new TextDecoder();
    let timer;
    return new TransformStream({
        transform (chunk, controller) {
            if (!(chunk instanceof Uint8Array)) {
                throw new Error('Unknown chunk type');
            }
            pending.push(chunk);
            if (/<\/\w+>$/.test(decoder.decode(chunk))) {
                clearTimeout(timer);
                timer = setTimeout(()=>{
                    controller.enqueue(concatUint8Arrays(pending.splice(0)));
                });
            }
        },
        flush (controller) {
            clearTimeout(timer);
            if (pending.length) {
                controller.enqueue(concatUint8Arrays(pending.splice(0)));
            }
        }
    });
};
const parseHtmlAttrs = (attrs)=>{
    // HACK this is very brittle
    const result = {};
    const kebab2camel = (s)=>s.replace(/-./g, (m)=>m[1].toUpperCase());
    const matches = attrs.matchAll(/(?<=^|\s)([^\s=]+)="([^"]+)"(?=\s|$)/g);
    for (const match of matches){
        result[kebab2camel(match[1])] = match[2];
    }
    return result;
};
const buildHtml = (createElement, attrs, head, body)=>createElement('html', attrs ? parseHtmlAttrs(attrs) : null, createElement('head', {
        dangerouslySetInnerHTML: {
            __html: head
        }
    }), createElement('body', {
        'data-hydrate': true
    }, body));
export const renderHtml = async (opts)=>{
    const { config, pathname, searchParams, htmlHead, renderRscForHtml, getSsrConfigForHtml, isDev } = opts;
    const loadClientModule = (key)=>isDev ? import(/* @vite-ignore */ CLIENT_MODULE_MAP[key]) : opts.loadModule(CLIENT_PREFIX + key);
    const [{ default: { createElement } }, { default: { renderToReadableStream } }, { default: { createFromReadableStream } }, { ServerRoot }] = await Promise.all([
        loadClientModule('react'),
        loadClientModule('rd-server'),
        loadClientModule('rsdw-client'),
        loadClientModule('waku-client')
    ]);
    const ssrConfig = await getSsrConfigForHtml?.(pathname, searchParams);
    if (!ssrConfig) {
        return null;
    }
    let stream;
    try {
        stream = await renderRscForHtml(ssrConfig.input, ssrConfig.searchParams || searchParams);
    } catch (e) {
        if (hasStatusCode(e) && e.statusCode === 404) {
            return null;
        }
        throw e;
    }
    const moduleMap = new Proxy({}, {
        get (_target, filePath) {
            return new Proxy({}, {
                get (_target, name) {
                    if (isDev) {
                        // TODO too long, we need to refactor this logic
                        let file = filePath.slice(config.basePath.length).split('?')[0];
                        const isFsPath = file.startsWith('@fs/');
                        file = '/' + (isFsPath ? file.slice('@fs/'.length) : file);
                        const fileWithAbsolutePath = isFsPath ? file : encodeFilePathToAbsolute(joinPath(opts.rootDir, file));
                        const wakuDist = joinPath(fileURLToFilePath(import.meta.url), '../../..');
                        if (fileWithAbsolutePath.startsWith(wakuDist)) {
                            const id = 'waku' + fileWithAbsolutePath.slice(wakuDist.length).replace(/\.\w+$/, '');
                            if (!moduleLoading.has(id)) {
                                moduleLoading.set(id, import(/* @vite-ignore */ id).then((m)=>{
                                    moduleCache.set(id, m);
                                }));
                            }
                            return {
                                id,
                                chunks: [
                                    id
                                ],
                                name
                            };
                        }
                        const id = filePathToFileURL(file);
                        if (!moduleLoading.has(id)) {
                            moduleLoading.set(id, opts.loadServerFile(id).then((m)=>{
                                moduleCache.set(id, m);
                            }));
                        }
                        return {
                            id,
                            chunks: [
                                id
                            ],
                            name
                        };
                    }
                    // !isDev
                    const id = filePath.slice(config.basePath.length);
                    if (!moduleLoading.has(id)) {
                        moduleLoading.set(id, opts.loadModule(joinPath(DIST_SSR, id)).then((m)=>{
                            moduleCache.set(id, m);
                        }));
                    }
                    return {
                        id,
                        chunks: [
                            id
                        ],
                        name
                    };
                }
            });
        }
    });
    const [stream1, stream2] = stream.tee();
    const elements = createFromReadableStream(stream1, {
        ssrManifest: {
            moduleMap,
            moduleLoading: null
        }
    });
    const body = createFromReadableStream(ssrConfig.body, {
        ssrManifest: {
            moduleMap,
            moduleLoading: null
        }
    });
    const readable = (await renderToReadableStream(buildHtml(createElement, config.htmlAttrs, htmlHead, createElement(ServerRoot, {
        elements
    }, body)), {
        onError (err) {
            console.error(err);
        }
    })).pipeThrough(rectifyHtml()).pipeThrough(injectScript(config.basePath + config.rscPath + '/' + encodeInput(ssrConfig.input), isDev ? `${config.basePath}${config.srcDir}/${SRC_MAIN}` : '')).pipeThrough(injectRSCPayload(stream2));
    return readable;
};
