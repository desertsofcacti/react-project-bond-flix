/// <reference types="react/canary" />
'use client';
import { createContext, createElement, memo, use, useCallback, useState, startTransition } from 'react';
import RSDWClient from 'react-server-dom-webpack/client';
import { encodeInput, encodeActionId } from './lib/renderers/utils.js';
const { createFromFetch, encodeReply } = RSDWClient;
const BASE_PATH = `${import.meta.env?.WAKU_CONFIG_BASE_PATH}${import.meta.env?.WAKU_CONFIG_RSC_PATH}/`;
const checkStatus = async (responsePromise)=>{
    const response = await responsePromise;
    if (!response.ok) {
        const err = new Error(response.statusText);
        err.statusCode = response.status;
        throw err;
    }
    return response;
};
const getCached = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);
const cache1 = new WeakMap();
const mergeElements = (a, b)=>{
    const getResult = ()=>{
        const promise = new Promise((resolve, reject)=>{
            Promise.all([
                a,
                b
            ]).then(([a, b])=>{
                const nextElements = {
                    ...a,
                    ...b
                };
                delete nextElements._value;
                promise.prev = a;
                resolve(nextElements);
            }).catch((e)=>{
                a.then((a)=>{
                    promise.prev = a;
                    reject(e);
                }, ()=>{
                    promise.prev = a.prev;
                    reject(e);
                });
            });
        });
        return promise;
    };
    const cache2 = getCached(()=>new WeakMap(), cache1, a);
    return getCached(getResult, cache2, b);
};
const fetchCache = [];
export const fetchRSC = (input, searchParamsString, setElements, cache = fetchCache, unstable_onFetchData)=>{
    let entry = cache[0];
    if (entry && entry[0] === input && entry[1] === searchParamsString) {
        entry[2] = setElements;
        return entry[3];
    }
    const options = {
        async callServer (actionId, args) {
            const response = fetch(BASE_PATH + encodeInput(encodeActionId(actionId)), {
                method: 'POST',
                body: await encodeReply(args)
            });
            const data = createFromFetch(checkStatus(response), options);
            unstable_onFetchData?.(data);
            const setElements = entry[2];
            startTransition(()=>{
                // FIXME this causes rerenders even if data is empty
                setElements((prev)=>mergeElements(prev, data));
            });
            return (await data)._value;
        }
    };
    const prefetched = globalThis.__WAKU_PREFETCHED__ ||= {};
    const url = BASE_PATH + encodeInput(input) + (searchParamsString ? '?' + searchParamsString : '');
    const response = prefetched[url] || fetch(url);
    delete prefetched[url];
    const data = createFromFetch(checkStatus(response), options);
    unstable_onFetchData?.(data);
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    cache[0] = entry = [
        input,
        searchParamsString,
        setElements,
        data
    ];
    return data;
};
export const prefetchRSC = (input, searchParamsString)=>{
    const prefetched = globalThis.__WAKU_PREFETCHED__ ||= {};
    const url = BASE_PATH + encodeInput(input) + (searchParamsString ? '?' + searchParamsString : '');
    if (!(url in prefetched)) {
        prefetched[url] = fetch(url);
    }
};
const RefetchContext = createContext(()=>{
    throw new Error('Missing Root component');
});
const ElementsContext = createContext(null);
export const Root = ({ initialInput, initialSearchParamsString, cache, unstable_onFetchData, children })=>{
    const [elements, setElements] = useState(()=>fetchRSC(initialInput || '', initialSearchParamsString || '', (fn)=>setElements(fn), cache, unstable_onFetchData));
    const refetch = useCallback((input, searchParams)=>{
        (cache || fetchCache).splice(0); // clear cache before fetching
        const data = fetchRSC(input, searchParams?.toString() || '', setElements, cache, unstable_onFetchData);
        setElements((prev)=>mergeElements(prev, data));
    }, [
        cache,
        unstable_onFetchData
    ]);
    return createElement(RefetchContext.Provider, {
        value: refetch
    }, createElement(ElementsContext.Provider, {
        value: elements
    }, children));
};
export const useRefetch = ()=>use(RefetchContext);
const ChildrenContext = createContext(undefined);
const ChildrenContextProvider = memo(ChildrenContext.Provider);
export const Slot = ({ id, children, fallback, unstable_shouldRenderPrev })=>{
    const elementsPromise = use(ElementsContext);
    if (!elementsPromise) {
        throw new Error('Missing Root component');
    }
    let elements;
    try {
        elements = use(elementsPromise);
    } catch (e) {
        if (e instanceof Error && !('statusCode' in e)) {
            // HACK we assume any error as Not Found,
            // probably caused by history api fallback
            e.statusCode = 404;
        }
        if (unstable_shouldRenderPrev?.(e) && elementsPromise.prev) {
            elements = elementsPromise.prev;
        } else {
            throw e;
        }
    }
    if (!(id in elements)) {
        if (fallback) {
            return fallback;
        }
        throw new Error('Not found: ' + id);
    }
    return createElement(ChildrenContextProvider, {
        value: children
    }, elements[id]);
};
export const Children = ()=>use(ChildrenContext);
/**
 * ServerRoot for SSR
 * This is not a public API.
 */ export const ServerRoot = ({ elements, children })=>createElement(ElementsContext.Provider, {
        value: elements
    }, children);
